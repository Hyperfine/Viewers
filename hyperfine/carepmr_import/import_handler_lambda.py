import logging
import os
import urllib.parse
from io import BufferedRandom, BytesIO
import boto3
from pydicom import dcmread
from pydicom.dataset import Dataset
from dicomweb_client.api import DICOMwebClient
from dicomweb_client.log import configure_logging
import requests

root = logging.getLogger()
if root.handlers:
    for handler in root.handlers:
        root.removeHandler(handler)
logging.basicConfig(format="%(asctime)s %(message)s", level=logging.INFO)

logger = logging.getLogger(__name__)

s3 = boto3.client("s3")

PMR_SERIAL_NUMBERS = os.getenv('PMR_SERIAL_NUMBERS', "Missing")
DICOM_WEB_URL = os.getenv("DICOM_WEB_URL", "Missing")


def get_serial_numbers():
    """Returns list of serial numbers which will be pushed
    to DICOM target.
    """
    return PMR_SERIAL_NUMBERS.split(",")


def upload_dicom(ds: Dataset, dicomweb_url: str, access_token: str = None) -> str:
    """Uploads a single DICOM Dataset to the specified dicom-web URL.

    If an access token is specified it is put into HTTP header.

    Args:
        ds (Dataset): Any valid DICOM object
        dicomweb_url (str): http/https url to the dicom-web service.
        access_token (str): Security token for accessing the URL.

    Raises:
        RuntimeError: _description_


    Returns:
        str: SOPInstanceUID of input dataset returned by the server.
    """
    if access_token:
        client = DICOMwebClient(
            url=dicomweb_url,
            headers={"Authorization": "Bearer {}".format(access_token)}
        )
    else:
        client = DICOMwebClient(url=dicomweb_url)

    # The result is a DICOM object containing fields
    # defined by table 6.6.1-2:
    # https://dicom.nema.org/dicom/2013/output/chtml/part18/sect_6.6.html#table_6.6.1-2
    result = client.store_instances(datasets=[ds])

    if not result:
        raise RuntimeError("Store instances returned null")

    warning_message = result.get('WarningReason', None)
    if warning_message:
        logger.warn(f'Warning {warning_message} for upload {ds.SOPInstanceUID}')
    failed_transfers = result.FailedSOPSequence
    if len(failed_transfers) > 0:
        reason = result.get('FailureReason', "")
        raise RuntimeError(
            f"Failed STOW-RS uploads {failed_transfers} {reason}")
    successful_transfers = result.ReferencedSOPSequence
    if len(successful_transfers) == 0:
        raise RuntimeError("There were no successful transfers")

    elif len(successful_transfers) != 1:
        raise RuntimeError(
            f"Expected only one transfer, not {len(successful_transfers)}"
        )
    sop_instance_uid = successful_transfers[0].ReferencedSOPInstanceUID

    return sop_instance_uid


def read_dcm_from_memory(in_memory_file: BufferedRandom) -> Dataset:
    """Returns a pydicom Dataset from an in-memory buffer.

    Args:
        in_memory_file (BufferedRandom): binary object from S3

    Raises:
        DICOMReadException: If object can not be parsed.

    Returns:
        Dataset: valid pyDICOM dataset.
    """
    try:
        dataset = dcmread(BytesIO(in_memory_file))
        return dataset
    except Exception as err:
        logger.error(f"DICOM read failure for file {in_memory_file}: {err}")
        logger.exception(err)
        raise RuntimeError("DICOM I/O parsing error")


def get_dicom_from_event(s3_client, event) -> Dataset:
    """Returns DICOM object from S3.

    Args:
        s3_client (_type_): S3 Client
        event (_type_): AWS Event generated by S3 trigger.

    Returns:
        Dataset: DICOM Object
    """
    bucket = event["Records"][0]["s3"]["bucket"]["name"]
    key = urllib.parse.unquote_plus(
        event["Records"][0]["s3"]["object"]["key"], encoding="utf-8"
    )
    s3_object = s3_client.get_object(Bucket=bucket, Key=key)
    file_content = s3_object["Body"].read()
    ds = read_dcm_from_memory(file_content)
    return ds


def is_carepmr_image(ds: Dataset) -> bool:
    """Returns True if the object should be forwarded to
    the CarePMR PACS; otherwise False.

    Args:
        ds (Dataset): Candidate DICOM object

    Returns:
        bool: True if the object's device serial number
        matches one of the serial numbers specified
        in an environment variable.
    """
    serial_number = ds.DeviceSerialNumber
    serial_number_dictionary = get_serial_numbers()
    if serial_number in serial_number_dictionary:
        return True
    else:
        return False


def lambda_handler(event, context):

    try:

        ds = get_dicom_from_event(s3, event)
        serial_number = ds.DeviceSerialNumber
        logger.info(f"DeviceSerialNumber = {serial_number}")

        if is_carepmr_image(ds):
            logger.info("Match - this is a CarePMR study")
            result = upload_dicom(ds, DICOM_WEB_URL)
            if not result:
                logger.error("upload_dicom failed")
                return None
            else:
                return {'SOPInstanceUID': result}
        else:
            logger.info("This is not a CarePMR study")
            return None

    except Exception as e:
        logger.exception(e)
        bucket = event["Records"][0]["s3"]["bucket"]["name"]
        key = urllib.parse.unquote_plus(
            event["Records"][0]["s3"]["object"]["key"], encoding="utf-8")
        logger.error(
            "Error uploading object {} from bucket {} to PACS.".format(
                key, bucket
            )
        )
        raise e
    return None


if __name__ == "__main__":  # For testing only
    configure_logging(4)
    token = get_token()
    filename = "tests/data/2.25.127421887010676750942174422891255180378.dcm"
    #filename = "tests/data/1.3.6.1.4.1.5962.99.1.2256093408.737520867.1651523567840.64.0.dcm"
    ds = dcmread(filename)
    server_url = "https://pacs-server.dev-sean.hyperfine-research-dev.com/pacs/dicom-web"
    #server_url = "http://127.0.0.1/pacs/dicom-web"
    status = upload_dicom(ds, server_url, token)
    print(status)
